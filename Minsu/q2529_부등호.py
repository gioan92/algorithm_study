# https://www.acmicpc.net/problem/2529
# 두 종류의 부등호 기호 ‘<’와 ‘>’가 k개 나열된 순서열  A가 있다.
# 우리는 이 부등호 기호 앞뒤에 서로 다른 한 자릿수 숫자를 넣어서 모든 부등호 관계를 만족시키려고 한다.
# 예를 들어, 제시된 부등호 순서열 A가 다음과 같다고 하자.
# A =>  < < < > < < > < >
# 부등호 기호 앞뒤에 넣을 수 있는 숫자는 0부터 9까지의 정수이며 선택된 숫자는 모두 달라야 한다.
# 아래는 부등호 순서열 A를 만족시키는 한 예이다.
# 3 < 4 < 5 < 6 > 1 < 2 < 8 > 7 < 9 > 0
# 이 상황에서 부등호 기호를 제거한 뒤, 숫자를 모두 붙이면 하나의 수를 만들 수 있는데
# 이 수를 주어진 부등호 관계를 만족시키는 정수라고 한다. 그런데 주어진 부등호 관계를 만족하는 정수는 하나 이상 존재한다.
# 예를 들어 3456128790 뿐만 아니라 5689023174도 아래와 같이 부등호 관계 A를 만족시킨다.
# 5 < 6 < 8 < 9 > 0 < 2 < 3 > 1 < 7 > 4
# 여러분은 제시된 k개의 부등호 순서를 만족하는 (k+1)자리의 정수 중에서 최댓값과 최솟값을 찾아야 한다.
# 앞서 설명한 대로 각 부등호의 앞뒤에 들어가는 숫자는
# { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }중에서 선택해야 하며 선택된 숫자는 모두 달라야 한다.
# 입력: 첫 줄에 부등호 문자의 개수를 나타내는 정수 k가 주어진다.
# 그 다음 줄에는 k개의 부등호 기호가 하나의 공백을 두고 한 줄에 모두 제시된다. k의 범위는 2 ≤ k ≤ 9 이다.
# 출력: 여러분은 제시된 부등호 관계를 만족하는 k+1 자리의 최대, 최소 정수를 첫째 줄과 둘째 줄에 각각 출력해야 한다.
# 단 아래 예(1)과 같이 첫 자리가 0인 경우도 정수에 포함되어야 한다.
# 모든 입력에 답은 항상 존재하며 출력 정수는 하나의 문자열이 되도록 해야 한다.

k = int(input());
ineqList = input().split(' ');
used = [False] * 10;
min = '';
max = '';

# 반복문을 k+1번 반복해야하므로 재귀함수 이용
# 출력은 문자열
# order는 1오름차순 / -1내림차순. 최소 최대만 찾기 위해
# 최솟값 또는 최댓값을 찾으면 전역변수 min 또는 max에 값이들어가고 값이 있으면 함수를 더 이상 실행하지 않고 중단함
def recur(cnt, result, order):
    global min, max;
    if cnt > k:
        if order == 1 and min == '':
            min = result;
        elif order == -1 and max == '':
            max = result;
        return;
    if order == 1: # 오름차순 range(0, 10 ,1)
        numStart = 0;
        numEnd = 10;
    elif order == -1: # 내림차순 range(9, -1, -1)
        numStart = 9;
        numEnd = -1;
    for i in range(numStart, numEnd, order):
        if (order == 1 and min != '') or (order == -1 and max != ''):
            break;
        else:
            if not used[i]: # 사용된 적 없는 숫자
                # 첫 번째 숫자일때 값을 넣고 재귀함수 호출
                # 그 다음 숫자부터 result의 마지막에 들어간숫자와 비교해서 부등식이 성립할때 재귀함수 호출
                if cnt == 0 or ((ineqList[cnt - 1] == '<') and (int(result[-1]) < i)) or ((ineqList[cnt - 1] == '>') and (int(result[-1]) > i)):
                    used[i] = True;
                    recur(cnt + 1, result + str(i), order);
                    used[i] = False; # 맞는 숫자가 없어 재귀함수를 빠져나올경우 해당 숫자 사용안함

recur(0, '', -1);
used = [False] * 10;
recur(0, '', 1);
print(min);
print(max);